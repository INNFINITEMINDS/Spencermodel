// Trying to reconstruct Spencer's model of Octopus cells (Spencer et al 2012)
// using their article. Note that their model may not be appropriate
// because real dendritic tree *violate* the Rall's '3/2' power low, so it  can
// not be represented with a few unic cylinders. Don't know if it can cause
// uncertaintes in currents.

// Active conductances: | Soma {Gklt, Gkht, Gh}  | Dends {Gklt, Gh, Gsyn} |
//                      | Axon {None -- myelin?} | Initial {Gna}          |

// [Gh] Bal & Oertel, 2000 (params: celcius = 33, frac = 1)
// [Gklt] Rothman & Manis, 2003 (params: celcius = 33, ek = -70, gkltbar = 0.0407)
// [Ghlt] Rothman & Manis, 2003 (params: celcius = 33, ek = -70, gkltbar = 0.0061)
// [Gna] Rothman & Manis, 2003
// [Gnas] Rothman et al. 1993 (referenced in Spencer et al. 2012)
// [Gsyn] 


// Their model includes values of parameters that mostly reflect experimentaly
// observed in cat


create soma, initial, axon, dend[4]

soma {
    nseg = 1
    diam = 25
    L = 25
    
    insert kltoz
    insert khtoz
    insert hcno // The frac = 0.8 followind McGinley2012 article.
    insert nas 
    
    gbar_nas = 0 
    gbar_hcno = 0.0076
    
    ek = -70
}

axon {
    nseg = 1
    diam = 3
    L = 30
    insert kltoz
    insert khtoz
    insert hcno 
    insert nas 
    
    gbar_kltoz = 0
    gbar_khtoz = 0
    gbar_hcno = 0
    gbar_nas  = 0
}

initial {
    nseg = 1
    diam = 3
    L = 10
    
    insert kltoz
    insert khtoz
    insert hcno 
    insert nas 
    
    gbar_kltoz = 0
    gbar_khtoz = 0
    gbar_hcno = 0
    gbar_nas  = 4.2441
    
    ena = 55
}
Nseg = 20
for i = 0, 3 {
    dend[i] {
	nseg = Nseg
	diam = 3
	L = 280
	
	insert kltoz
	insert khtoz
	insert hcno 
	insert nas 
	
	gbar_khtoz = 0
	gbar_nas  = 0
	gbar_hcno = 0.0006
	gbar_kltoz = 0.0027 // from Spencer et al., 2012, Table 3

	ek = -70 
	
	//THERE IS NO KHT CONDUCTANCE IN DENDS IN Spencer et al 2012//
    }
}

forall {
    insert leak
    cm = 0.9 // uF/cm^2
    Ra = 100 // mho*cm
    
    ek = -70
    ena = 55
    
    //e_pas = -62 // mV. Golding et al. 1999; Bal & Oertel 2001
    //g_pas = 0.002 // S/cm^2. Calculated from time constant and cell capasitance
    // values from Bal & Oertel, 2000; Bal & Baydas 2009
}


// ------------------- DENDRITIC INNERVATION --------------------------- //

ndst = 80 // Number of synapses on a single dendrite.
objref dst0[ndst], dst1[ndst], dst2[ndst], dst3[ndst]

delay = 0.0036 //ms

// Calculated as mean delay time during which an EPSP reaches 
// the soma (mean with respect to 10 different locations of the
// synapse along a dendrite was 0.029 ms. Then it was recalculated
// for 80 synapses: 0.029*(1/8) = 0.0036 ms)

// In cats total travelling wave delay is 8 ms. The number of ANFs
// innervating an octopus cell is unknown for me yet.
// Delay for a single synapse can be assessed roughly:
// (8/3)/80 = 0.033 ms, 10 times delay variable (1/3 of tonotopy is crossed by a single octopus neuron)
// In mice: (1.6/3)/80 = 0.0067 -- 2 times.

for i = 0, (ndst-1) {
    dend[0] dst0[i] = new syn(( 1/ndst )*( i + 1 )) 
    dst0[i].onset = 300  - delay*i
    
    dend[1] dst1[i] = new syn(( 1/ndst )*( i + 1 ))
    dst1[i].onset = 300  - delay*i
    
    dend[2] dst2[i] = new syn(( 1/ndst )*( i + 1 ))
    dst2[i].onset = 300  - delay*i
    
    dend[3] dst3[i] = new syn(( 1/ndst )*( i + 1 ))
    dst3[i].onset = 300  - delay*i
}

proc dendfire() {
    
    for i = 0, (ndst-1) {
	dst0[i].gmax = 0.002
	dst1[i].gmax = 0.002
	dst2[i].gmax = 0.002
	dst3[i].gmax = 0.002
    }
    run()  
    
    for i = 0, (ndst-1) {
	dst0[i].gmax = 0
	dst1[i].gmax = 0
	dst2[i].gmax = 0
	dst3[i].gmax = 0
    }

}


// ------------------- CONNECT THINGS TOGETHER ------------------------- //
 
connect initial(1), axon(0)
connect axon(1), soma(0)

for i = 0, 3 {
    connect dend[i](0), soma(1)
}



tstop = 500
celsius = 37
finitialize(-60)

// ------------------ PICTURES ---------------------------------------- //

// 1. Soma & initial v(t)

objref pic, pic1, pic2

pic = new Graph()

addplot(pic, 0)
pic.size(0, 500, -70, 20)
pic.addvar("soma.v(.5)", 3, 1)
pic.addvar("initial.v(.5)", 2, 1)

// 2. Dendritic innervation v(t)

pic1 = new Graph()

addplot(pic1, 0)
pic1.size(245, 254, -65, -45)
pic1.addvar("dend[1].v(.5)", 1, 1)
pic1.addvar("soma.v(.5)", 3, 1)
pic1.addvar("initial.v(.5)", 2, 1)

// 3. Currents in dend[0](.5), soma i(t)

pic2 = new Graph()

addplot(pic2, 0)
pic2.size(0, 1000, -0.02, 0.04)

pic2.addvar("dend[0].ik_kltoz(.5)", 1, 1)
pic2.addvar("dend[0].i_hcno(.5)", 3, 1)
pic2.addvar("dend[0].i_leak(.5)", 2, 1)
pic2.addvar("soma.ik_kltoz(.5)", 5, 6)
pic2.addvar("soma.i_hcno(.5)", 6, 6)
pic2.addvar("soma.i_leak(.5)", 7, 6)

// ------------------ SOMATIC INNERVATION: stimtrain, stairs, stm1 ----- //

objref stim[5], stm, st[2]

for i = 0, 4 { soma stim[i] = new IClamp(.5) }

for i = 0, 1 { soma st[i] = new IClamp(.5) }

soma stm = new IClamp(.5)

// 1. Creates a train of 5 current pulses
proc stimtrain() { local amp, dur, interval,  del
    amp = $1 // current pulses' amplitude
    dur = $2 // current pulses' duration
    interval = $3 // time interval between current pulses
    del = $4 // delay 
    
    for i = 0, 4 {
	
	stim[i].dur = dur
	stim[i].amp = amp
	stim[i].del = del + i*interval
    }
    run()
    //stimulate once and turn off!
    for i = 0, 4 { stim[i].amp = 0 }
}

// 2. Creates double current pulse
proc stairs() { local amp1, amp2, dur1, dur2, interval, del  
    // current steps 1/2 superimposed
    amp1 = $1
    amp2 = $2
    dur1 = $3
    dur2 = $4
    interval = $5
    del = $6
    
    
    st[0].amp = amp1 // nA
    st[0].dur = dur1
    st[0].del = del
    
    st[1].amp = amp2
    st[1].dur = dur2
    st[1].del = del + interval
    
    run()
    
    //stimulate once and turn off!
    st[0].amp = 0
    st[1].amp = 0
}

// 3. Creates a single current pulse
proc stm1() { local amp, dur, del
    amp = $1
    dur = $2
    del = $3
    
   
    stm.amp = amp
    stm.dur = dur
    stm.del = del
    
    run()
    
    //stimulate once and turn off! 
    stm.amp = 0
}



/*
// Culculates total Iklt current in 4 dends in nA
func calc_cur_klt() { 
    Isumklt =0
    for n =0,3{
	for l = 0,dend[n].nseg-1 {
	    x = (l+0.5)/dend[n].nseg
	    i = dend[n].ik_kltoz(x)
	    
	    Isumklt += i
	}
    }
    Isumklt *= 3.1415*dend[0].diam*dend[0].L*1e-8/dend[0].nseg
    return Isumklt*1e6
}

// Culculates total Ih current in 4 dends in nA
func calc_cur_h() {
    Isumh =0
    for n =0,3{
	for l = 0,dend[n].nseg-1 {
	    x = (l+0.5)/dend[n].nseg
	    i = dend[n].i_hcno(x)
	    //print x, i, Isumh
	    Isumh += i
	}
    }
    Isumh *= 3.1415*dend[0].diam*dend[0].L*1e-8/dend[0].nseg
    return Isumh*1e6
}

// Culculates total Ileak current in 4 dends in nA
func calc_cur_leak() {
    Isumle=0
    for n =0,3{
	for l = 0,dend[n].nseg-1 {
	    x = (l+0.5)/dend[n].nseg
	    i = dend[n].i_leak(x)
	    
	    Isumle += i
	}
    }
    Isumle *= 3.1415*dend[0].diam*dend[0].L*1e-8/dend[0].nseg
    return Isumle*1e6
}



// For saving iklt currents of all dend[0] segments into a file

objref rect, reci[20], reci1[20], reci2[20], recn[20], recn1[20], recn2[20]

for i = 0, 19 {
    rect = new Vector()
    reci[i] = new Vector()
    reci1[i] = new Vector()
    reci2[i] = new Vector()
    
    rect.record(&t)
    reci[i].record(&dend[0].ik_kltoz(0.049*(i+1)))
    reci1[i].record(&dend[0].i_hcno(0.049*(i+1)))
    reci2[i].record(&dend[0].i_leak(0.049*(i+1)))
}
run()

for i = 0, 19 {
    recn[i] = new Vector(rect.size())
    recn1[i] = new Vector(rect.size())
    recn2[i] = new Vector(rect.size())
    
    for j = 0,rect.size()-1 {
	recn[i].x[j] = reci[i].x[j] - dend[0].ik_kltoz(0.049*(i+1))
	recn1[i].x[j] = reci1[i].x[j] - dend[0].i_hcno(0.049*(i+1))
	recn2[i].x[j] = reci2[i].x[j] - dend[0].i_leak(0.049*(i+1))
    }
}
//получили значения токов, нормированные на стационарные значения. для каждого сегмента. теперь надо записать их в файл!
//Сначала запишем их все в матрицу, а потом в один файл. Потом интегрировать

objref m[3], f[3]

for i = 0, 2 {
    m[i] = new Matrix()
    m[i].resize(rect.size(), 21)
    m[i].setcol(0, rect)
    
    f[i] = new File()
}

for j = 0, 19 {
    m[0].setcol((j+1), recn[j])
    m[1].setcol((j+1), recn1[j])
    m[2].setcol((j+1), recn2[j])
}

// Matrix done. Now write segments' currents into a file 


f[0].wopen("dend_Iklt(t)_norm.dat")
f[1].wopen("dend_Ih(t)_norm.dat")
f[2].wopen("dend_Ileak(t)_norm.dat")

for i = 0,2 {
    f[i].printf("t, dend location: 0 -> 1, 20 segments\n")
    m[i].fprint(f[i], " %03e")
    f[i].close()
}
*/

// Записали, получили 3 файла с токами(t) (нормированными на равновесное значение). Теперь надо найти те точки, 
// в которых происходит стимуляция и релаксация и еще там. по rect используя where(rect.x[i], ">", onset, но
// "<" какое-то время релаксации, равновесинизации токов). Получить этот интервал значений. По нему
// интегрировать каждый ток в каждом сегменте (60 интегралов). Сложить интегралы для каждого тока. Получится 
//суммарный "extra" ток, протекающий через мембрану при иннервации дендритов. Посчитать суммарный ток каждого 
// иона. Отсюда посчитать энергит. затраты. Это будет Энергия, требуемая на иннервацию дендритов на одно событие
//(одна иннервация, один sweep без шумов)

//Проблемы: расчет составляющих Na+ и K+ в токе Ih
//where usage
//интегрирование 60 кривых в питоне